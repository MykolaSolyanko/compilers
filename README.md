# Компиляция и система сборки
В нашем курсе мы больше будем работать с GCC пакетом, т.е. gcc компилятором и g++

GCC это некий toolchain(набор инструментов), т.е. это пакет который содержит большую группу компиляторов для разных языков прпограммирования. С самого начало своего существования он поддерживал только язык С, ну логично, но потом начал расширяться до поодержки других языков.
Нас интересует компиляторы gcc и g++. Стоит заметить что gcc компилятор есть главным компилятором для сборки ряда популярных OS 

## gcc и g++
Часто говорят что это компиляторы, т.к. по больше привыкли так называть, но на самом деле это прогшраммы, которые делают за кулисами следующие действия препроцессинг, компиляция, и линковка.
На самом деле эти две программы выполняют абсолютно одинаковые действия, но разница у них только в процессе линковики.

### Препроцессинг
Препроцессинг это самый первый этам когда мы собираем нашшу программу, на этом этапе происходит раскрытие всех макросов, и `include` деректив, т.е подготавливаеться исходный код(просто текстовый файл) для следующего этапа компиляции.

### Компиляция
Копилятор, он уже преобразует ваш исходный код, или текстовые данные, в язык программирования. Т.е. он на самом деле строит лексические, синтаксическое дерево и т.д., на основе исходного кода, и если что то есть, которое нарушает это построение дерав, т.е. то что не поддерживаеться компилятором или с его точки зрения есть ошибкой,то компилятор выдаст вам ошибку компиляции с небольшим описанием и возсожной рекомендацией по устранению ошибки. Дальше после построения и анализа синтаксически коретного вашего исходного кода, компиятор начинает преробразовывать этот код в машинные инструкции, или объектные файлы. Иногда компиляцию можно преобразовать в асемблерный язык. Например на Unix системах это ELF формат ( Executable and Linkable Format), т.е это некий двоичный файл (иногда называемый двоичным интерфейсом). В этом файле может содержаться таблицы символов, информация о функциях которые не определены в данном моделу трансляции. Но и это также полноценно исполняемый файл.

### Линковка
Задача линковщика очень проста, она связывает все созданные ранее компиятором объектные файлы в один исполняемый файл. Его задача, после компиляции найти определения функций, типов, котрые были вставленные компилятором при процессе компиляции

А теперь в чем же отличие gcc от g++
Компилятор gcc он может компилировать как файлы c/cpp, т.е. в зависимости от расширения, он их будет по разному синтаксически рассматривать. В то время как g++ будет любой файл c/cpp рассматривать как С++ файл. Также что важно g++ линкует стандартную библиотеку С++, в то время как gcc этого не делает. Но это и логично, т.к. gcc при компиляции может компилить как C программу, которой С++ библиотека не нужна.
Скомпилируем простую программу С++ двумя компиляторами
```cpp
#include <iostream>

int func(int a) {
  return a;
}
int main(int argc, char const *argv[]) {
  std::cout << func(0) << std::endl; 
  return 0;
}

```
Сначала скомпилируем ее спомощью gcc
`gcc main.cpp -o main`
Т.е. тут мы вызываем компилятор, передаем на вход ей исходный код(модуль трансляции), и линкеру говорим какое выходное имя исполняемого файла у нас будет
Но если мы запустим такую команду, то получим поток ошибок
```
/tmp/ccp1ruHh.o: In function `main':
main.cpp:(.text+0x28): undefined reference to `std::cout'
main.cpp:(.text+0x2d): undefined reference to `std::ostream::operator<<(int)'
main.cpp:(.text+0x32): undefined reference to `std::basic_ostream<char, std::char_traits<char> >& std::endl<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&)'
main.cpp:(.text+0x3a): undefined reference to `std::ostream::operator<<(std::ostream& (*)(std::ostream&))'
/tmp/ccp1ruHh.o: In function `__static_initialization_and_destruction_0(int, int)':
main.cpp:(.text+0x68): undefined reference to `std::ios_base::Init::Init()'
main.cpp:(.text+0x77): undefined reference to `std::ios_base::Init::~Init()'
collect2: error: ld returned 1 exit status
```

Т.е. как видим линкер пытаеться найти наш объект потока, вызвать функции для вывода на экран числа. Проблема как было сказано в том что нам необходимо сказать компилятору где определены эти функции и объекты. Есть два места где они могут быть определены это в нашей программе и в библиотеке. В нашей программе нет определения наших функций, соответсвенно линкер будет искать это в библиотеке. Но линкеру надо указать что это за библиотека, т.к. на компъютере их может быть нереально много, поэтому мы должны указать в какой именно библиотеке. Но чтобы пойти дальше в двух словах что такое библиотека.
Библиотека это то же исполняемый компилируемый файл идея которого следующея. Например мы написали крутой функционал работы кучи, и этот функционал необходимо использовать в нескольких программах и вместо копирования функционала, для этого пишут библиотеки, которые представляют скоплириуемый совместно используемый код. Но есть два типа библиотек это статическая и динамическая.
Статическая это когда весь код библиотеки встраиваетиься или правильно сказать мапится(вставляеться) в нашу программу. Но есть много минусов этого, это то что код нашей программы становиться больше на размер этой библиотеки, второй если что то поменялось, то необходимо перекомпилировать нашу программу. Но работа с приложения становиться быстрей.
Динамическая. При линковке, линковщих, грубо говоря добавляет так называемые заглушки типа с именами библиотек, и библиотека если она не была загружена в память, то она загружаеться, и необходимое адрессное пространство библиотекимапится в память приложения(виртуальное адрессное пространство). Т.е. вывод что если при запуске приложения не будет найдено библиогтеку, то наша программа не запуститься. Другой вариант если необходимого имени функции нет в библиотеке, то наша программа таже не загрузиться. Приимуществом есть то что нам не надо перекомпилировать программу, если что то поменялось в динамической библиотеке, т.е. для этого просто надо обновить библиотеку и перезапустить нашу программу. Другой тип динамической загрузки это когда вместо нашей ос мы сами загружаем нужную нам библиотеку, когда нам это нужно.

Теперь когда мы разобрались что такое библиотеки, теперь понятно что нужно gcc указать библиотеку где находиться определения этих функций. В данном случае это libstdc++. Ок давайте соберем нашу программу, теперь с другой строкой сборки.
`gcc main.cpp -lstdc++ -o main`
Как видим спомощью `-lstdc++` мы указываем что мы думаем что функции вывода на печать находяться в этой библиотеке. При компиляции нам не нужно указывать, `libstdc++`, т.е. полное имя. Мы указываем опцию `-l` и в имени скипаем `lib`. И наша программа собралась без ошибок.

Ок, теперь запустим на сборку наше приложение, спомощью компилятора `g++`
`g++ main.cpp -o main`

Если запустить данную команду, то у нас все собереться без ошибок, т.е. нам не надо указывать дополнительных библиотек при зборке, т.к. g++ сделает это автоматически, он понимает где искать определения функций и т.д. Но это касаеться только стандартных библиотек, пользовательские необходимо указывать самостоятельно.

Все выше примеры зауска можно задавать без указания имени исполняемого файла, т.е. можно `-o main`  опускать вместо этого компилятор подставит имя по умолчанию. В Linux это a.out.

Т.е. при сборке программы у нас есть два вида ошибок, 1-й это ошибка компиляции, т.е. синтаксическая ошибка, 2-я это ошибка линковки, т.е. когда линковщик не может найти реализацию функции, объекта, и т.д..

Иногда можно услышать такие понятия как компилятор эсть бекэнд часть, а аргументы компилятора это фронэнд часть. Т.е. компилятору на вход подаеться модуль трансляции, и он его преобразет во ствое внутренее преставление, т.е. бекэнд

Следующие команды разбиваються на отдельные этапы.
1. Этап препроцессинга.
`g++ -E main.cpp`
Эта команда раскрывает все макросы и инклуд файлы

2. Этап компиляции.
`g++ -S main.cpp`
Получение ассемблерного кода
`g++ -c main.cpp`
Получение объектного файла `main.o`

3. Следующая команда соберет объектные файлы в испролняемый один файл
`g++  main.o -o main`

Немного слов о еще одном популярном компиялторе это clang, его цель немного другая, т.е. он транслирует исходные коды в байт код, который потом производит оптимизацию и и кодегенерацию. Т.е. clang есть просто частью пакета LLVM.

MinGW минимизированный GCC под Windows.

## Раздельная компиляция
Давайте начнем с того что такое единица трансляции, это наш исходный код который после обработки препроцессором, являеться входным набором для компилятора. Так вот раздельная компиялция, это когда у нас программа состоит из множества таких единиц трансляции, и компилятор поочередно компилирует каждый модуль трансляции, формируя объектные файлы которые потом линкует в исполняемый файл линковщик. Ок, так а зачем нам необходимо отдельные модули трансляции.Ну во-первых это чтобы не нагромождать один модуль трансляции, т.е. чем больше будет модуль трансляции, тем дольше будет компиляция. Еще это упрощает чтения кода, т.е. когда один модуль трансляции представляет функционал конкретной задачи. Во вторых это вынесение одной конкретной задачи, или набор функциий характеризующий логически связанный функционал. Т.е. например мы хотим вынести работу с очередью в отдельный файл, что бы все функции по работе с очередью можно было изменять только в одном файле, т.е. менять его поведение, а части программы которые используют функционал этой очереди(интерейс), не зависили от внутренего поведения.Т.е. таким образом мы разделяем интерфейс и его реализацию.
Но в этом есть важное такое поведение, если мы например поменяем что то в нашем коде с очередью, т.е. ее реализацию, то нам не нужно будет перекомпилировать все модули трансляции, нам достаточно скомпилировать только один модуль, и потом линкер свяжет это в новый исполняемый файл. Т.е. например, у нас есть 3 файла, если мы первый раз компилируем все наши файлы, то будут компилироваться все наши файлы, потом например мы решили в одном из этих файлов поменять реализацию функции, при этом не меняя интерфейсную часть(список параметров функции, или типы параметров, или набор этих параметров), то компилятор перекомпилит только один модуль трансляции. Но если например мы поменяли интерфейсную часть функции, то будут также перекомпилированы и другие модули трансляции в которых были вызовы этих функций.
Давайте теперь начнем писать примеры. Давайте например создадим два файла С++. Один из функцией main, а другой файл будет содержать например функции для логирования(писать debug, info error).
Файл `main.cpp` содержит следующий код
```cpp
#include <cstdio>

struct SummResult {
  long int summ;
  bool status;
};

constexpr unsigned int SIZE_PRINT_BUF = 300;

SummResult calc(const int* ptr1, const int* ptr2) {
  SummResult result{0, false};
  log_info(__func__);
  if (ptr1 == nullptr || ptr2 == nullptr) {
    log_error("Pointer is null");    
    return result;
  }
  result.status = true;
  result.summ = *ptr1 + *ptr2;
  log_debug("Summ succfully calculate");
  return result;
}

int main(int argc, char const *argv[]) {
    char log_buff[SIZE_PRINT_BUF] = "Summ calculate was failed";
    int value1 = 90;
    int value2 = 100;
    auto summ = calc(&value1, &value2);
    if (!summ.status) {
      log_error(log_buff);
    } else {
      sprintf(log_buff, "%s %ld", "The summ is = ", summ.summ);
      log_debug(log_buff);
    }
    
    return 0;
}
```

А файл `log.cpp` содержит следующий код
```cpp
#include <iostream>

void log_error(const char* str) {
  std::cerr << str << std::endl;
}

void log_info(const char* str) {
  std::cerr << str << std::endl;
}

void log_debug(const char* str) {
  std::cerr << str << std::endl;
}
```

Т.е. идея программы простая мы выполняем сложение двух чисел. И логируем наши действия выполняемые в фyнкции `main`.
Если мы запустим сборку нашей программы со следующей командой, то получим  следующие ошибки
`g++ -Wall -pedantic log.cpp main.cpp`
То на экране мы получим следующий сообщения об ошибке.
```
main.cpp: In function ‘SummResult calc(const int*, const int*)’:
main.cpp:12:3: error: ‘log_info’ was not declared in this scope
   log_info(__func__);
   ^~~~~~~~
main.cpp:14:5: error: ‘log_error’ was not declared in this scope
     log_error("Pointer is null");
     ^~~~~~~~~
main.cpp:14:5: note: suggested alternative: ‘perror’
     log_error("Pointer is null");
     ^~~~~~~~~
     perror
main.cpp:19:3: error: ‘log_debug’ was not declared in this scope
   log_debug("Summ succfully calculate");
   ^~~~~~~~~
main.cpp: In function ‘int main(int, const char**)’:
main.cpp:29:7: error: ‘log_error’ was not declared in this scope
       log_error(log_buff);
       ^~~~~~~~~
main.cpp:29:7: note: suggested alternative: ‘perror’
       log_error(log_buff);
       ^~~~~~~~~
       perror
main.cpp:32:7: error: ‘log_debug’ was not declared in this scope
       log_debug(log_buff);
       ^~~~~~~~~
main.cpp:32:7: note: suggested alternative: ‘log_buff’
       log_debug(log_buff);
       ^~~~~~~~~
       log_buff

```
Как видим при компиляции мы получили ошибку компиляции, т.е. компилятор не нашел подходящего объявления для вызываемых функций, и придложил объявления который есть в инкул файле cstdio. Ок, как видим мы провалились на этапе компиляции, и для того чтобы у нас прошла компиляция, нам необходимо объявить прототипы(интерфейсы) этих функций. Ок давайте объявим их в файле main.cpp
```
void log_error(const char* str);
void log_info(const char* str);
void log_debug(const char* str);

```

И если мы опять запустим сборку, то все скомпилируеться без ошибок. И если мы запустим нашу программу, то получим следующее на экране
```
calc
Summ succfully calculate
The summ is =  190

```
Ну потом мы решили например поменять в файле log.cpp название функции с `log_debug` на `log_verbose`. И при этом мы забыли поменять прототип функции в файле main.cpp. И опять запустим сборку, то получим мы уже следующие ошибки.
```
/tmp/ccNS5CvX.o: In function `calc(int const*, int const*)':
main.cpp:(.text+0x7b): undefined reference to `log_debug(char const*)'
/tmp/ccNS5CvX.o: In function `main':
main.cpp:(.text+0x1b4): undefined reference to `log_debug(char const*)'
collect2: error: ld returned 1 exit status

```
Т.е. теперь мы получаем ошибку линковки, т.е. компиляция прошла нормально, а вот линковщик не смог найти реализации функции `log_debug`.

Ок, как видим в раздельной компиляции есть одна проблема что если мы выносим функционал в отдельно компилируемый файл, то нам надо в каждый файл где мы используем этот функционал объвлять какой интерфейс этой функции. И если например этот функционал испольуеться в одном файле, то в принцепе ок, но если например он используеться в 10 файлах, то нам надо в каждом из этих файлов делать объявления этих функций. И как видим из примера выше если мы изменили интерфейс одной из функций, то нам необхордимо в каждом файле где использовался старый интерфейс, объявить новый. Ну вообщем это не только напряжно, представляете если у нас проэкт из 100 файлов и каждый из них использует логирования.
Для этой проблемы используються дериктива препроцессора `#include`

## Заголовочный файл
Для выше описаной проблемы и применяют заголовочные файлы, т.е. это такой файл в котором выносят объявление типов или функций которые будет использоваться в других модулях трансляции. Мы до этого уже использовали заголовочные файлы, когда использовали функции со стандартной библиотеки. Но реализация этих функций как было описано выше находиться в библиотечных файлах. Заголовочные файлы в основном пишут с расширением `.h` или `.hpp`, но на самом деле абсолютно нет никакой разницы какие именно файлы с какими расширениями вы будете писать, это принятое соглашение что заголовочные файлы имеет следующие  рассширениия. Заголовочные файлы подключаються к вашему модулю трансляции с помощью директивы препроцессора `#include`, и эта директива обрабатываеться препроцессором. Т.е. при этапе препроцессинга, там где указано например `include "log.hpp"`, то препроцессор выполнит макроподстановку, простым словом возьмет все содержимое этого файла и скопирует в файле где эта дериктива подключаеться. Таким образом мы написав только в одном файле, и подключив в тех модулях трансляции где будет использоваться этот функционал, то препроцессор сделает за нас всю работу копи-паста.

Есть некоторые разницы как указывать после директивы `#include`. Если два места где препроцессор ищит фаши заголовочные файл. Это место где находиться ваш заголовочный файл, и второе место, это где указано в переменной среды окружения, в Linux, это `PATH`. Второй способ это указания заголовочного файла, это когда препроцессор ищет определенние функции  том же месте где лежит я файс молуля трансляции. Если после директивы `#include`, указать так `<имя_заголовочного_файла>`, то препроцеессор будет искать срузе в путях указаанных в переменных окружения. И если после этой директивы указать `""`, то препроцессор будет искать сначала там где лежит ваш модуль трансляции. Т.е. указав правильный используемый символ, то вы не тоолько упростите жизнь препроцессору в поисках необходимого точки поиска, но упрощаете жизнь читающему ваш код. Так же в заголовочном файле модно указывать путь где находиться наш файл.
Ок давайте добавим заголовочный файл в наш проект, вынеся туда интерфейсы функции определнных в файле log.cpp/
```cpp
void log_error(const char* str);
void log_info(const char* str);
void log_debug(const char* str);

```
И добвим подключения этого заголовочного файла в наш main.cpp. Ок, если мы запустим нашу программу, то все скомпилируеться нормально. И если собрать наше прграмму добавив опцию -E, то мы увидим что компилятор просто вставляет содержимое этого файла в файл включающий этот заголовочный файл.

Мы могли также вместо например файла log.cpp, добавить опеределения функций логирования в заголовочный файл. Но забегая вперед скажу что так мало кто делает, в основном в заголовочной файле определяет что делает ваш функционал, т.е. интерфейс,а в файл .cpp как делает этот функционал.
Ок если все перенести в log.cpp, и собрав например нашу программу, но только при сборке не указывать файл .cpp, то все собиреться нормально.
Как бы все ок, мы поняли что есть такое понятие заголовочный файл, ивыяснили что туда можно вносить как объявления функций, так и определения, так и объявления типов. Но это учебный пример, в реальных проектах где очнь много файлов, есть такое понятие как пересекающиеся include, с отдним и тем же заголовочным файлом, т.е. препроцессор когда начинает раскрывать эти заголовочные файлы, он может увидеть что в другом заголовочном файле уже есть включенный заголовочный файл который был раскрыт ранне. Т.е. происходит дублирование содержимого заголовочнорго файла.
Пример
```
A.cpp
#icnlude "C.hpp"
#include "B.hpp"

B.cpp
#icnlude "A.hpp"

B.hpp
#icnlude "C.hpp"
```

Как видим из примера выше что если мы раскроем #include "B.hpp" в модуле трансляции A.cpp, то у нас будет дублирования #icnlude "C.hpp", т.е. мы два раза скопируем содержимое C.hpp в файл A.cpp.
Теперь вы видете проблему? А проблема есть в том что если мы например в hpp файл добавили вместо объявления, определения функции, то будет ошибка redefinition function  error, т.е. переопределение функции. Но если бы в заголовочном файле было только объявление, то все было бы ок. Т.к. обяъвлений может быть очень много, а вот определения может быть только одно.
То же самое и касаеться типа данных.
Так а как решить эту проблему, а решаеться она просто в заголовочный файл добавляеться так называемые стражи. Суть их в том и заключаеться что если страж уже был расрыт для одного модуля трансляции(Важно то что страж расскрываеться работает только для одного модуля трансляции, а не для всех модулей трансляции проекта), то больше он не будет раскрываться(т.е. не будет дублироваться). Стражи пишут двух видов, тут правда дело вкуса.

1. Изпользуя макросы (include guard)
```
#ifndef LOG_HPP_
#define LOG_HPP_

void log_error(const char* str);
void log_info(const char* str);
void log_debug(const char* str);

#endif // LOG_HPP_ 
```
Т.е. мы определяем некое имя макроса если оно не определено. Т.е. при первом разе, т.е. раскрытии мы определяем имя макроса, вставляем туда объявления функций, потом если у нас еще раз в модуле трансляции появился еще такой же заголовочный файл, то при раскрытии препроцессор по условии #ifndef увидет что определено такое имя LOG_HPP_, и не будет копировать дальше содержимое этого заголовочного файла, т.к. он уже был включен. Имя макроса в заголовочном файле может быть любым, но по соглашению имен пишут название заголовочного файла.

2. Использование, назовем это утидлиты #pragma once. И она делает все тоже самое, только писать меньше. Т.е. она говорит что включи содержимое файла только один раз. Но там есть свои и сюрпризы, можете самостоятельно их почитать.

## Библиотеки
Библиотеки мы с вами уже рассмотрели в раздели Линковка. Но в двух словах чтобы освежить память. В библиотеке в основном выносят функционал который может использоваться в нескольких приложениях, или вы поставляете какойто функцианал, т.е. тот который не есть полноценной программой, например какуюто модную реализацию алгоритма шифрования.
Мы рассмотрим два варианта один это использования динамической(shared) и статической библиотеки
Для этого вынесим файлы log.hpp и log.cpp в отдельную папку по работе. И следующей командой запустим сборку shared library.
`g++ -std=c++14 -Wall -Werror -fPIC *.cpp -shared -o log.so`
Тут много всяких букв, но важной тут есть `-shared`, которая говорит что мы собираем shared библиотеку и опция `fPic` которая важна при адресации функций.
На выходе мы получим файл `log.so`.
А теперь давайте слинкуем нашу библиотеку к нашему проэкту. Если мы запустим команду
`g++ -std=c++14 *.cpp -o main`

То получим ошибку компиляции
```
main.cpp:2:19: fatal error: log.hpp: No such file or directory
compilation terminated.
```

Т.е. компилятор не может найти где находиться этот заголовочный файл. Для решения этой проблемы при компияляции надо указать путь к этому заголовочному файлу.
`g++ -std=c++14 -I../work_with_shared_library *.cpp -o main`
Т.е. опцией `-I` мы указываем пути к нашему заголовочному файлу
Если запустим, то компиляция пройдет на гуд, а вот линковщик не сможет найти определения функции, но и это очевидно он же не знает где это искать)
```
/tmp/ccGqHKBn.o: In function `calc(int const*, int const*)':
main.cpp:(.text+0x31): undefined reference to `log_info(char const*)'
main.cpp:(.text+0x49): undefined reference to `log_error(char const*)'
main.cpp:(.text+0x75): undefined reference to `log_debug(char const*)'
/tmp/ccGqHKBn.o: In function `main':
main.cpp:(.text+0x170): undefined reference to `log_error(char const*)'
main.cpp:(.text+0x1a9): undefined reference to `log_debug(char const*)'
collect2: error: ld returned 1 exit status

```

Ну для этого нам надо указать путь где лежит библиотека и плюс имя самой библиотеки

`g++ -std=c++14 -L../work_with_shared_library/ -Wl,-rpath=../work_with_shared_library/  -I../work_with_shared_library  main.cpp -llog -o main`

После выполнения данной команды у нас собереться программа без ошибок

Теперь давайте соберем этот же код только как статическую библиотеку.
Для этого мы делаем две вещи, первое собираем объектные файлы следующей командой
`g++ -c *.cpp`

А второе, что самое смешное, мы его собираем как архив, т.е. копируем все объектные файлы в архив
`ar -rc  liblog.a *.o`
Т.е. набор объектных файлов мы копируем в один файл
Собираеться все также как и для shared библиотеке
`g++ -std=c++14 -L../work_with_static_library/ -Wl,-rpath=../work_with_static_library  -I../work_with_static_library  main.cpp -llog -o main`

Но если посмотреть размер исполняемого файла, собраного как с шаред библиотеке, и статичекой. То мы увидем как программа собраная со статической библиотекой будет весить немного больше, т.к. статическая библиотека, подгружаеться прямо в исполняемый файл.

## Система сборки
Но писать такие строки сборки используя CLI, явлеться утомительным и есть источником больших ошибок, к примеру наш код исполует много других заголовочных файлов, с разных проектов. Или много подключаемых библиотек. То в больших проектах используют систему сборки.
Самой популярной есть Makefile. Это обычные текстовые файлы со своим синтаксисом, который обрабатывет программа `make`, также как и gcc, со своими правилами граматики и синтаксиса.

Напишем простой Makefile с подключаемой библиотекой.

```Makefile
CC=g++

INCLUDE=-I../work_with_shared_library
CFLAGS=-std=c++14 -c -Wall
LIB_PATH=../work_with_shared_library
RPATH=-rpath=$(LIB_PATH)
LD_PATH=-L$(LIB_PATH) -Wl,$(RPATH)
all: main

main: main.o
		 $(CC) $(LD_PATH) main.o -llog -o main

main.o:
			$(CC) $(CFLAGS) $(INCLUDE) main.cpp
clean:
			rm -f *.o main
```
Как видим этот файл сборки просто дублирует, то что мы писали выше только через CLI

Но такую сборку тяжело читать, да и плюс он не переносим

Для этого использую CMake. Это используеться для генерации, систем сборки для разных платформ
Давайте напишем простой CMakeLists.txt

```C
cmake_minimum_required(VERSION 3.6)

project(logining C CXX)

set (PROJECT_LINK_LIBS liblog.so)

link_directories(../work_with_shared_library)

include_directories(../work_with_shared_library)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")

add_executable(main main.cpp)

target_link_libraries(main ${PROJECT_LINK_LIBS})
```
Для сборки надо выполнить две команды, это создать директорию build, потом выполнить команду cmake, которая сгенерирует Makefile, а потом запускаем уже наш make. Как видно из примера CMake есть более описываемый чем Makefile